// "use strict";function _toConsumableArray(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}var _extends=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t};!function(){function t(t){function e(t){t.parentElement.removeChild(t)}function n(t,e,n){var o=0===n?t.children[0]:t.children[n-1].nextSibling;t.insertBefore(e,o)}function o(t,e){return t.map(function(t){return t.elm}).indexOf(e)}function i(t,e,n){if(!t)return[];var o=t.map(function(t){return t.elm}),i=[].concat(_toConsumableArray(e)).map(function(t){return o.indexOf(t)});return n?i.filter(function(t){return t!==-1}):i}function r(t,e){var n=this;this.$nextTick(function(){return n.$emit(t.toLowerCase(),e)})}function s(t){var e=this;return function(n){null!==e.realList&&e["onDrag"+t](n),r.call(e,t,n)}}var a=["Start","Add","Remove","Update","End"],l=["Choose","Sort","Filter","Clone"],u=["Move"].concat(a,l).map(function(t){return"on"+t}),d=null,c={options:Object,list:{type:Array,required:!1,"default":null},value:{type:Array,required:!1,"default":null},noTransitionOnDrag:{type:Boolean,"default":!1},clone:{type:Function,"default":function(t){return t}},element:{type:String,"default":"div"},move:{type:Function,"default":null}},f={name:"draggable",props:c,data:function(){return{transitionMode:!1,componentMode:!1}},render:function(t){var e=this.$slots["default"];if(e&&1===e.length){var n=e[0];n.componentOptions&&"transition-group"===n.componentOptions.tag&&(this.transitionMode=!0)}var o=e,i=this.$slots.footer;return i&&(o=e?[].concat(_toConsumableArray(e),_toConsumableArray(i)):[].concat(_toConsumableArray(i))),t(this.element,null,o)},mounted:function(){var e=this;if(this.componentMode=this.element.toLowerCase()!==this.$el.nodeName.toLowerCase(),this.componentMode&&this.transitionMode)throw new Error("Transition-group inside component is not supported. Please alter element value or remove transition-group. Current element value: "+this.element);var n={};a.forEach(function(t){n["on"+t]=s.call(e,t)}),l.forEach(function(t){n["on"+t]=r.bind(e,t)});var o=_extends({},this.options,n,{onMove:function(t,n){return e.onDragMove(t,n)}});!("draggable"in o)&&(o.draggable=">*"),this._sortable=new t(this.rootContainer,o),this.computeIndexes()},beforeDestroy:function(){this._sortable.destroy()},computed:{rootContainer:function(){return this.transitionMode?this.$el.children[0]:this.$el},isCloning:function(){return!!this.options&&!!this.options.group&&"clone"===this.options.group.pull},realList:function(){return this.list?this.list:this.value}},watch:{options:{handler:function(t){for(var e in t)u.indexOf(e)==-1&&this._sortable.option(e,t[e])},deep:!0},realList:function(){this.computeIndexes()}},methods:{getChildrenNodes:function(){if(this.componentMode)return this.$children[0].$slots["default"];var t=this.$slots["default"];return this.transitionMode?t[0].child.$slots["default"]:t},computeIndexes:function(){var t=this;this.$nextTick(function(){t.visibleIndexes=i(t.getChildrenNodes(),t.rootContainer.children,t.transitionMode)})},getUnderlyingVm:function(t){var e=o(this.getChildrenNodes()||[],t);if(e===-1)return null;var n=this.realList[e];return{index:e,element:n}},getUnderlyingPotencialDraggableComponent:function(t){var e=t.__vue__;return e&&e.$options&&"transition-group"===e.$options._componentTag?e.$parent:e},emitChanges:function(t){var e=this;this.$nextTick(function(){e.$emit("change",t)})},alterList:function(t){if(this.list)t(this.list);else{var e=[].concat(_toConsumableArray(this.value));t(e),this.$emit("input",e)}},spliceList:function h(){var t=arguments,h=function(e){return e.splice.apply(e,t)};this.alterList(h)},updatePosition:function m(t,e){var m=function(n){return n.splice(e,0,n.splice(t,1)[0])};this.alterList(m)},getRelatedContextFromMoveEvent:function(t){var e=t.to,n=t.related,o=this.getUnderlyingPotencialDraggableComponent(e);if(!o)return{component:o};var i=o.realList,r={list:i,component:o};if(e!==n&&i&&o.getUnderlyingVm){var s=o.getUnderlyingVm(n);if(s)return _extends(s,r)}return r},getVmIndex:function(t){var e=this.visibleIndexes,n=e.length;return t>n-1?n:e[t]},getComponent:function(){return this.$slots["default"][0].componentInstance},resetTransitionData:function(t){if(this.noTransitionOnDrag&&this.transitionMode){var e=this.getChildrenNodes();e[t].data=null;var n=this.getComponent();n.children=[],n.kept=void 0}},onDragStart:function(t){this.context=this.getUnderlyingVm(t.item),t.item._underlying_vm_=this.clone(this.context.element),d=t.item},onDragAdd:function(t){var n=t.item._underlying_vm_;if(void 0!==n){e(t.item);var o=this.getVmIndex(t.newIndex);this.spliceList(o,0,n),this.computeIndexes();var i={element:n,newIndex:o};this.emitChanges({added:i})}},onDragRemove:function(t){if(n(this.rootContainer,t.item,t.oldIndex),this.isCloning)return void e(t.clone);var o=this.context.index;this.spliceList(o,1);var i={element:this.context.element,oldIndex:o};this.resetTransitionData(o),this.emitChanges({removed:i})},onDragUpdate:function(t){e(t.item),n(t.from,t.item,t.oldIndex);var o=this.context.index,i=this.getVmIndex(t.newIndex);this.updatePosition(o,i);var r={element:this.context.element,oldIndex:o,newIndex:i};this.emitChanges({moved:r})},computeFutureIndex:function(t,e){if(!t.element)return 0;var n=[].concat(_toConsumableArray(e.to.children)).filter(function(t){return"none"!==t.style.display}),o=n.indexOf(e.related),i=t.component.getVmIndex(o),r=n.indexOf(d)!=-1;return r||!e.willInsertAfter?i:i+1},onDragMove:function(t,e){var n=this.move;if(!n||!this.realList)return!0;var o=this.getRelatedContextFromMoveEvent(t),i=this.context,r=this.computeFutureIndex(o,t);return _extends(i,{futureIndex:r}),_extends(t,{relatedContext:o,draggedContext:i}),n(t,e)},onDragEnd:function(t){this.computeIndexes(),d=null}}};return f}if(Array.from||(Array.from=function(t){return[].slice.call(t)}),(typeof exports == "object")){var e=require("sortablejs");module.exports=t(e)}else if("function"==typeof define&&define.amd)define(["sortablejs"],function(e){return t(e)});else if(window&&window.Vue&&window.Sortable){var n=t(window.Sortable);Vue.component("draggable",n)}}();
(function () {
    "use strict";
  
    if (!Array.from) {
      Array.from = function (object) {
        return [].slice.call(object);
      }
    }
  
    function buildAttribute(object, propName, value) {
      if (value == undefined) {
        return object;
      }
      object = (object == null) ? {} : object;
      object[propName] = value;
      return object;
    }
  
    function buildDraggable(Sortable) {
      function removeNode(node) {
        node.parentElement.removeChild(node)
      }
  
      function insertNodeAt(fatherNode, node, position) {
        const refNode = (position === 0) ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling
        fatherNode.insertBefore(node, refNode)
      }
  
      function computeVmIndex(vnodes, element) {
        return vnodes.map(elt => elt.elm).indexOf(element)
      }
  
      function computeIndexes(slots, children, isTransition) {
        if (!slots) {
          return []
        }
  
        const elmFromNodes = slots.map(elt => elt.elm);
        const rawIndexes = [...children].map(elt => elmFromNodes.indexOf(elt))
        return isTransition ? rawIndexes.filter(ind => ind !== -1) : rawIndexes
      }
  
      function emit(evtName, evtData) {
        this.$nextTick(() => this.$emit(evtName.toLowerCase(), evtData))
      }
  
      function delegateAndEmit(evtName) {
        return (evtData) => {
          if (this.realList !== null) {
            this['onDrag' + evtName](evtData)
          }
          emit.call(this, evtName, evtData)
        }
      }
  
      const eventsListened = ['Start', 'Add', 'Remove', 'Update', 'End']
      const eventsToEmit = ['Choose', 'Sort', 'Filter', 'Clone']
      const readonlyProperties = ['Move', ...eventsListened, ...eventsToEmit].map(evt => 'on' + evt)
      var draggingElement = null
  
      const props = {
        options: Object,
        list: {
          type: Array,
          required: false,
          default: null
        },
        value: {
          type: Array,
          required: false,
          default: null
        },
        noTransitionOnDrag: {
          type: Boolean,
          default: false
        },
        clone: {
          type: Function,
          default: (original) => { return original; }
        },
        element: {
          type: String,
          default: 'div'
        },
        move: {
          type: Function,
          default: null
        },
        componentData: {
          type: Object,
          required: false,
          default: null
        }
      }
  
      const draggableComponent = {
        name: 'draggable',
  
        props,
  
        data() {
          return {
            transitionMode: false,
            noneFunctionalComponentMode: false,
            init: false
          }
        },
  
        render(h) {
          const slots = this.$slots.default
          if (slots && slots.length === 1) {
            const child = slots[0]
            if (child.componentOptions && child.componentOptions.tag === "transition-group") {
              this.transitionMode = true
            }
          }
          let children = slots
          const { footer } = this.$slots
          if (footer) {
            children = slots ? [...slots, ...footer] : [...footer]
          }
          var attributes = null;
          const update = (name, value) => { attributes = buildAttribute(attributes, name, value); };
          update('attrs', this.$attrs);
          if (this.componentData) {
            const { on, props } = this.componentData;
            update('on', on);
            update('props', props);
          }
          return h(this.element, attributes, children);
        },
  
        mounted() {
          this.noneFunctionalComponentMode = this.element.toLowerCase() !== this.$el.nodeName.toLowerCase()
          if (this.noneFunctionalComponentMode && this.transitionMode) {
            throw new Error(`Transition-group inside component is not supported. Please alter element value or remove transition-group. Current element value: ${this.element}`);
          }
          var optionsAdded = {};
          eventsListened.forEach(elt => {
            optionsAdded['on' + elt] = delegateAndEmit.call(this, elt)
          });
  
          eventsToEmit.forEach(elt => {
            optionsAdded['on' + elt] = emit.bind(this, elt)
          });
  
          const options = Object.assign({}, this.options, optionsAdded, { onMove: (evt, originalEvent) => { return this.onDragMove(evt, originalEvent); } })
          !('draggable' in options) && (options.draggable = '>*');
          this._sortable = new Sortable(this.rootContainer, options)
          this.computeIndexes()
        },
  
        beforeDestroy() {
          this._sortable.destroy()
        },
  
        computed: {
          rootContainer() {
            return this.transitionMode ? this.$el.children[0] : this.$el;
          },
  
          isCloning() {
            return (!!this.options) && (!!this.options.group) && (this.options.group.pull === 'clone')
          },
  
          realList() {
            return (!!this.list) ? this.list : this.value;
          }
        },
  
        watch: {
          options: {
            handler(newOptionValue) {
              for (var property in newOptionValue) {
                if (readonlyProperties.indexOf(property) == -1) {
                  this._sortable.option(property, newOptionValue[property]);
                }
              }
            },
            deep: true
          },
  
          realList() {
            this.computeIndexes()
          }
        },
  
        methods: {
          getChildrenNodes() {
            if (!this.init) {
              this.noneFunctionalComponentMode = this.noneFunctionalComponentMode && this.$children.length == 1
              this.init = true;
            }
  
            if (this.noneFunctionalComponentMode) {
              return this.$children[0].$slots.default
            }
            const rawNodes = this.$slots.default
            return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes
          },
  
          computeIndexes() {
            this.$nextTick(() => {
              this.visibleIndexes = computeIndexes(this.getChildrenNodes(), this.rootContainer.children, this.transitionMode)
            })
          },
  
          getUnderlyingVm(htmlElt) {
            const index = computeVmIndex(this.getChildrenNodes() || [], htmlElt)
            if (index === -1) {
              //Edge case during move callback: related element might be
              //an element different from collection
              return null
            }
            const element = this.realList[index]
            return { index, element }
          },
  
          getUnderlyingPotencialDraggableComponent({ __vue__ }) {
            if (!__vue__ || !__vue__.$options || __vue__.$options._componentTag !== "transition-group") {
              return __vue__
            }
            return __vue__.$parent
          },
  
          emitChanges(evt) {
            this.$nextTick(() => {
              this.$emit('change', evt)
            });
          },
  
          alterList(onList) {
            if (!!this.list) {
              onList(this.list)
            }
            else {
              const newList = [...this.value]
              onList(newList)
              this.$emit('input', newList)
            }
          },
  
          spliceList() {
            const spliceList = list => list.splice(...arguments)
            this.alterList(spliceList)
          },
  
          updatePosition(oldIndex, newIndex) {
            const updatePosition = list => list.splice(newIndex, 0, list.splice(oldIndex, 1)[0])
            this.alterList(updatePosition)
          },
  
          getRelatedContextFromMoveEvent({ to, related }) {
            const component = this.getUnderlyingPotencialDraggableComponent(to)
            if (!component) {
              return { component }
            }
            const list = component.realList
            const context = { list, component }
            if (to !== related && list && component.getUnderlyingVm) {
              const destination = component.getUnderlyingVm(related)
              if (destination) {
                return Object.assign(destination, context)
              }
            }
  
            return context
          },
  
          getVmIndex(domIndex) {
            const indexes = this.visibleIndexes
            const numberIndexes = indexes.length
            return (domIndex > numberIndexes - 1) ? numberIndexes : indexes[domIndex]
          },
  
          getComponent() {
            return this.$slots.default[0].componentInstance
          },
  
          resetTransitionData(index) {
            if (!this.noTransitionOnDrag || !this.transitionMode) {
              return
            }
            var nodes = this.getChildrenNodes()
            nodes[index].data = null
            const transitionContainer = this.getComponent()
            transitionContainer.children = []
            transitionContainer.kept = undefined
          },
  
          onDragStart(evt) {
            this.context = this.getUnderlyingVm(evt.item)
            evt.item._underlying_vm_ = this.clone(this.context.element)
            draggingElement = evt.item
          },
  
          onDragAdd(evt) {
            const element = evt.item._underlying_vm_
            if (element === undefined) {
              return
            }
            removeNode(evt.item)
            const newIndex = this.getVmIndex(evt.newIndex)
            this.spliceList(newIndex, 0, element)
            this.computeIndexes()
            const added = { element, newIndex }
            this.emitChanges({ added })
          },
  
          onDragRemove(evt) {
            insertNodeAt(this.rootContainer, evt.item, evt.oldIndex)
            if (this.isCloning) {
              removeNode(evt.clone)
              return
            }
            const oldIndex = this.context.index
            this.spliceList(oldIndex, 1)
            const removed = { element: this.context.element, oldIndex }
            this.resetTransitionData(oldIndex)
            this.emitChanges({ removed })
          },
  
          onDragUpdate(evt) {
            removeNode(evt.item)
            insertNodeAt(evt.from, evt.item, evt.oldIndex)
            const oldIndex = this.context.index
            const newIndex = this.getVmIndex(evt.newIndex)
            this.updatePosition(oldIndex, newIndex)
            const moved = { element: this.context.element, oldIndex, newIndex }
            this.emitChanges({ moved })
          },
  
          computeFutureIndex(relatedContext, evt) {
            if (!relatedContext.element) {
              return 0
            }
            const domChildren = [...evt.to.children].filter(el => el.style['display'] !== 'none')
            const currentDOMIndex = domChildren.indexOf(evt.related)
            const currentIndex = relatedContext.component.getVmIndex(currentDOMIndex)
            const draggedInList = domChildren.indexOf(draggingElement) != -1
            return (draggedInList || !evt.willInsertAfter) ? currentIndex : currentIndex + 1
          },
  
          onDragMove(evt, originalEvent) {
            const onMove = this.move
            if (!onMove || !this.realList) {
              return true
            }
  
            const relatedContext = this.getRelatedContextFromMoveEvent(evt)
            const draggedContext = this.context
            const futureIndex = this.computeFutureIndex(relatedContext, evt)
            Object.assign(draggedContext, { futureIndex })
            Object.assign(evt, { relatedContext, draggedContext })
            return onMove(evt, originalEvent)
          },
  
          onDragEnd(evt) {
            this.computeIndexes()
            draggingElement = null
          }
        }
      }
      return draggableComponent
    }
  
    if (typeof exports == "object") {
      var Sortable = require("sortablejs")
      module.exports = buildDraggable(Sortable)
    } else if (typeof define == "function" && define.amd) {
      define(['sortablejs'], function (Sortable) { return buildDraggable(Sortable); });
    } else if (window && (window.Vue) && (window.Sortable)) {
      var draggable = buildDraggable(window.Sortable)
      Vue.component('draggable', draggable)
    }
  })();
  